//insert函数将在二叉树中插入一个数据域为x的新结点
//注意根结点指针root要使用引用，否则插入不会成功
void insert(node* &root, int x) {
    if(root == NULL) {
        root = newNode(x);
        return;
    }
    if(有二叉树的性质，x应该插在左子树) {
        insert(root->lchild, x);
    } else {
        insert(root->rchild, x);
    }
}

//在上述代码中，很关键的一点是根结点指针root使用了引用&。引用的作用在前面已经介绍过，即在函数中修改root会直接修改原变量
//这么做是因为在insert函数中新建了结点，并把新结点的地址赋给了当层的root。
//如果不使用引用，root = new node这个语句对root的修改就无法作用到原变量(即上一层的root->lchild与root->rchild)上去，也就不能把新结点接到二叉树上面。
//因此insert函数必须加引用
//那么为什么前面的search函数不需要加引用呢？这是因为search函数中修改的是指针root指向的内容，而不是root本身，而对指针指向的结点内容的修改是不需要加引用的。
//详情可见前面关于参数传递的相关知识

//进一步看，如何判断我写这类函数的时候是否需要加引用呢？一般来说，如果函数中需要新建结点，即对二叉树的结构做出修改，就需要加引用；
//如果只是修改当前已有结点的内容，或仅仅是遍历树，就不用加引用。
//至于判断不出来的情况，不妨直接试一下加引用和不加引用的区别再来选择
//最后提醒，在新建结点之后，务必令新结点的左右指针域为NULL，表示这个新结点暂时没有左右子树
