//解决"寻找有序序列 第一个 满足某条件的元素的位置"问题的固定模板(左闭右闭)
//这是一个非常重要且经典的问题，平时能碰到的大部分二分法问题都可以归结于这个问题
//本模板所谓的"某条件"在序列中一定是 从左到右 先不满足，然后满足 的。(否则 把该条件取反即可)

//二分区间为 左闭右闭 的[left, right], 初值必须能覆盖解的所有可能取值
//首先，二分下界是0是显然的，但是二分上界 在这类问题中，应是n
//这是考虑到欲查询元素有可能比序列中的所有元素都要大，此时应当返回n(即假设它存在，它应该在的位置)，因此二分上界是n
//故二分的初始区间为[left, right] = [0, n]

int solve(int left, int right) {
	int mid;	//mid为left和right的中点
	while(left < right) {		//对[left, right]来说，left == right意味着找到唯一位置
		mid = (left + right) / 2;	//取中点，在left比int取值范围一半还大，所找位置又在比较靠后的情况下，一般采用另一种写法以规避溢出 mid = left + (right - left) / 2
		//mid = left + (right - left) / 2;
		if( 条件成立 ) {		//条件成立，第一个满足条件的元素的位置 <= mid
			right = mid;		//往左子区间[left, mid]查找
		}
		else {					//条件不成立，则第一个满足该条件的元素的位置 > mid
			left = mid + 1;		//往右子区间[mid + 1, right]查找
		}
	}
	return left;				//返回夹出来的位置
}

//如何判断这类函数的查询是否成功，就是要注意对上界n的处理即可
